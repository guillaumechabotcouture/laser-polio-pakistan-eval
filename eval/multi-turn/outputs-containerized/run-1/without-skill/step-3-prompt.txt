Here is the code from the previous step:

```python
"""
4-Patch SEIR Model with Gravity-Model Spatial Coupling
using the LASER framework (laser-core).

Disease parameters
------------------
  R0                = 5.0
  Latent period     = 4 days   → sigma = 1/4  = 0.25 /day  (E → I rate)
  Infectious period = 10 days  → gamma = 1/10 = 0.10 /day  (I → R rate)
  beta              = R0 * gamma = 0.50 /day

Patches (arranged in a line, 75 km apart)
------------------------------------------
  Patch 0: 100 000 people   (position   0 km)
  Patch 1: 200 000 people   (position  75 km)
  Patch 2: 150 000 people   (position 150 km)
  Patch 3:  80 000 people   (position 225 km)

Spatial coupling — gravity model
---------------------------------
  G[i,j] = k * N_i^a * N_j^b / d_ij^c
  k=0.01, a=1, b=1, c=1.5  (patches 75 km apart in a line)

  Coupling fraction: f[i,j] = G[i,j] / N_i = k * N_j^b / d_ij^c
  Row-normalize: if sum_j f[i,j] > max_export, scale row uniformly so
    sum equals max_export (= 0.15).
  Full mixing matrix: phi[i,j] = f[i,j] for j≠i;
                      phi[i,i] = 1 - sum_{j≠i} f[i,j]

  Force of infection: FOI_i = beta * (phi @ I_frac)[i]
    where I_frac[j] = I_j[t] / N_j

Initial conditions (applied to every patch)
--------------------------------------------
  S₀ = 90%,  E₀ = 0%,  I₀ = 1%,  R₀ = 9%

Duration: 365 days (1 year)

Framework notes
---------------
  * laser_core.PropertySet  — parameter container with attribute-style access
  * laser_core.LaserFrame   — columnar store; node state arrays are vector
    properties with shape (nticks+1, n_patches), i.e. time-first indexing.
  * Components follow the laser.generic pattern: each has a step(tick) method
    that reads state[tick] and accumulates changes into state[tick+1].
  * _initialize_flows copies state[tick] → state[tick+1] at the start of
    every tick so each component only has to add or subtract its own flow.
"""

import numpy as np
import geopandas as gpd
import matplotlib.pyplot as plt
from shapely.geometry import Point

from laser_core import LaserFrame, PropertySet


# =========================================================================
# 1.  PARAMETERS
# =========================================================================

R0                = 5.0
latent_period     = 4.0    # days
infectious_period = 10.0   # days

gamma = 1.0 / infectious_period   # 0.10 /day
sigma = 1.0 / latent_period       # 0.25 /day
beta  = R0 * gamma                # 0.50 /day

params = PropertySet({
    "nticks":             365,
    "beta":               beta,
    "sigma":              sigma,
    "gamma":              gamma,
    "R0":                 R0,
    "latent_period":      latent_period,
    "infectious_period":  infectious_period,
    "prng_seed":          20260101,
})


# =========================================================================
# 2.  SCENARIO  —  4-patch GeoDataFrame (laser Model convention)
# =========================================================================

patch_populations = np.array([100_000, 200_000, 150_000, 80_000], dtype=np.int64)
n_patches         = len(patch_populations)

S0    = np.floor(patch_populations * 0.90).astype(np.int64)
E0    = np.zeros(n_patches, dtype=np.int64)
I0    = np.floor(patch_populations * 0.01).astype(np.int64)
R0arr = patch_populations - S0 - E0 - I0

coords = [(-87.6, 41.8), (-88.0, 40.7), (-86.2, 39.8), (-89.4, 43.1)]

scenario = gpd.GeoDataFrame(
    {
        "nodeid":     np.arange(n_patches),
        "population": patch_populations,
        "S":          S0,
        "E":          E0,
        "I":          I0,
        "R":          R0arr,
    },
    geometry=[Point(lon, lat) for lon, lat in coords],
    crs="EPSG:4326",
)

print("=" * 60)
print("4-Patch SEIR Model — LASER Framework (gravity coupling)")
print("=" * 60)
print(f"\nParameters: R0={params.R0}  beta={params.beta:.4f}"
      f"  sigma={params.sigma:.4f}  gamma={params.gamma:.4f}")
print(f"Duration  : {params.nticks} days\n")
print("Initial scenario:")
print(scenario[["nodeid", "population", "S", "E", "I", "R"]].to_string(index=False))
print()


# =========================================================================
# 3.  GRAVITY-MODEL COUPLING MATRIX
#
#     Patches in a line 75 km apart → positions [0, 75, 150, 225] km.
#
#     Step 1: raw gravity weights
#             G[i,j] = k * N_i^a * N_j^b / d_ij^c   (off-diagonal)
#
#     Step 2: coupling fractions (per-capita outflow)
#             f[i,j] = G[i,j] / N_i  for j ≠ i   (= k * N_j^b / d^c when a=1)
#
#     Step 3: row-cap at max_export = 0.15
#             if sum_{j≠i} f[i,j] > 0.15, scale the entire row uniformly
#             so the off-diagonal sum equals exactly 0.15.
#
#     Step 4: full mixing matrix
#             phi[i,j] = f[i,j]             for j ≠ i
#             phi[i,i] = 1 - sum_{j≠i} f[i,j]    (stay-at-home fraction)
#             Rows of phi sum to 1.
#
#     Force of infection (spatially coupled):
#             FOI_i = beta * sum_j phi[i,j] * I_j[t] / N_j
#                   = beta * (phi @ I_frac)[i]
# =========================================================================

patch_spacing_km = 75.0
positions_km     = np.arange(n_patches, dtype=np.float64) * patch_spacing_km
# [  0.,  75., 150., 225. ]

k_grav     = 0.01
a_grav     = 1.0
b_grav     = 1.0
c_grav     = 1.5
max_export = 0.15   # maximum off-diagonal row sum (travel fraction cap)

N_float = patch_populations.astype(np.float64)

# Distance matrix; diagonal → inf to avoid division by zero
dist_km   = np.abs(positions_km[:, None] - positions_km[None, :])  # (n, n)
dist_safe = np.where(dist_km == 0.0, np.inf, dist_km)

# Step 1 — raw gravity weights
G_raw = (
    k_grav
    * (N_float[:, None] ** a_grav)
    * (N_float[None, :] ** b_grav)
    / (dist_safe ** c_grav)
)
np.fill_diagonal(G_raw, 0.0)

# Step 2 — coupling fractions f[i,j] = G[i,j] / N_i
frac = G_raw / N_float[:, None]

# Step 3 — row-cap: scale rows whose off-diagonal sum exceeds max_export
off_diag_sums = frac.sum(axis=1)                             # shape (n,)
scale_vec     = np.where(
    off_diag_sums > max_export,
    max_export / off_diag_sums,
    1.0,
)
frac = frac * scale_vec[:, None]

# Step 4 — full mixing matrix (rows sum to 1)
phi = frac.copy()
np.fill_diagonal(phi, 1.0 - frac.sum(axis=1))

print("=== Gravity coupling matrix  phi[i,j] ===")
print("    (row = source patch, col = destination patch)")
print()
col_header = "         " + "".join(f"   P{j}" for j in range(n_patches))
print(col_header)
for i in range(n_patches):
    row_vals = "".join(f"  {phi[i, j]:6.4f}" for j in range(n_patches))
    travel_pct = (1.0 - phi[i, i]) * 100.0
    print(f"  P{i}  {row_vals}   [{travel_pct:.1f}% travel]")
print()


# =========================================================================
# 4.  NODE STATE STORE  —  LaserFrame with time-series vector properties
# =========================================================================

nticks = params.nticks

nodes = LaserFrame(n_patches)

nodes.add_vector_property("S", nticks + 1, dtype=np.float64)
nodes.add_vector_property("E", nticks + 1, dtype=np.float64)
nodes.add_vector_property("I", nticks + 1, dtype=np.float64)
nodes.add_vector_property("R", nticks + 1, dtype=np.float64)

nodes.add_vector_property("newly_exposed",    nticks + 1, dtype=np.float64)
nodes.add_vector_property("newly_infectious", nticks + 1, dtype=np.float64)
nodes.add_vector_property("newly_recovered",  nticks + 1, dtype=np.float64)

nodes.S[0] = S0.astype(np.float64)
nodes.E[0] = E0.astype(np.float64)
nodes.I[0] = I0.astype(np.float64)
nodes.R[0] = R0arr.astype(np.float64)


# =========================================================================
# 5.  SEIR COMPONENTS  (laser.generic component pattern)
# =========================================================================

class TransmissionSE:
    """
    S → E  :  spatially coupled force of infection.

    Without coupling (original):
        FOI_i = beta * I_i[t] / N_i

    With gravity coupling (this version):
        I_frac[j] = I_j[t] / N_j          (infectious fraction per patch)
        FOI_i     = beta * (phi @ I_frac)[i]
                  = beta * sum_j phi[i,j] * I_j[t] / N_j

    phi[i,j] is the mixing fraction: the share of patch i's effective
    contacts that come from patch j's infectious pool.  The diagonal
    phi[i,i] = stay-at-home fraction (0.85 when capped at 15% travel).

    Updates S[t+1] -= new_E,  E[t+1] += new_E.
    """

    def __init__(
        self,
        nodes:  LaserFrame,
        params: PropertySet,
        phi:    np.ndarray,        # (n_patches, n_patches) gravity coupling matrix
    ) -> None:
        self.nodes  = nodes
        self.params = params
        self.phi    = phi

    def step(self, tick: int) -> None:
        n      = self.nodes
        N      = n.S[tick] + n.E[tick] + n.I[tick] + n.R[tick]   # total pop per patch
        I_frac = n.I[tick] / N                                     # infectious fraction

        # Spatially weighted FOI: (n_patches,) vector
        foi   = self.params.beta * (self.phi @ I_frac)
        new_E = foi * n.S[tick]

        n.newly_exposed[tick + 1]  = new_E
        n.S[tick + 1]             -= new_E
        n.E[tick + 1]             += new_E


class ExposedProgression:
    """
    E → I  :  end of latent period, agents become infectious.

    new_I = sigma * E[t]

    Updates E[t+1] -= new_I,  I[t+1] += new_I.
    """

    def __init__(self, nodes: LaserFrame, params: PropertySet) -> None:
        self.nodes  = nodes
        self.params = params

    def step(self, tick: int) -> None:
        n     = self.nodes
        new_I = self.params.sigma * n.E[tick]

        n.newly_infectious[tick + 1] = new_I
        n.E[tick + 1]               -= new_I
        n.I[tick + 1]               += new_I


class InfectiousRecovery:
    """
    I → R  :  recovery after infectious period.

    new_R = gamma * I[t]

    Updates I[t+1] -= new_R,  R[t+1] += new_R.
    """

    def __init__(self, nodes: LaserFrame, params: PropertySet) -> None:
        self.nodes  = nodes
        self.params = params

    def step(self, tick: int) -> None:
        n     = self.nodes
        new_R = self.params.gamma * n.I[tick]

        n.newly_recovered[tick + 1] = new_R
        n.I[tick + 1]              -= new_R
        n.R[tick + 1]              += new_R


# =========================================================================
# 6.  MODEL ORCHESTRATOR
# =========================================================================

class SEIRModel:
    """
    Patch-level SEIR orchestrator following the laser.generic.Model design.

    Attributes
    ----------
    scenario   : GeoDataFrame  — patch metadata
    nodes      : LaserFrame    — time-series state store
    params     : PropertySet   — simulation parameters
    components : list          — ordered SEIR components
    """

    def __init__(
        self,
        scenario:   gpd.GeoDataFrame,
        nodes:      LaserFrame,
        params:     PropertySet,
        components: list,
    ) -> None:
        self.scenario   = scenario
        self.nodes      = nodes
        self.params     = params
        self.components = components

    def _initialize_flows(self, tick: int) -> None:
        """Forward-fill all state arrays tick → tick+1 (laser.generic convention)."""
        n = self.nodes
        n.S[tick + 1] = n.S[tick]
        n.E[tick + 1] = n.E[tick]
        n.I[tick + 1] = n.I[tick]
        n.R[tick + 1] = n.R[tick]

    def run(self) -> None:
        for tick in range(self.params.nticks):
            self._initialize_flows(tick)
            for component in self.components:
                component.step(tick)
        print(f"Simulation complete: {self.params.nticks} days, "
              f"{self.nodes.count} patches.\n")


# =========================================================================
# 7.  BUILD AND RUN
# =========================================================================

model = SEIRModel(
    scenario=scenario,
    nodes=nodes,
    params=params,
    components=[
        TransmissionSE(nodes, params, phi),   # phi passed in here
        ExposedProgression(nodes, params),
        InfectiousRecovery(nodes, params),
    ],
)

model.run()


# =========================================================================
# 8.  RESULTS SUMMARY
# =========================================================================

print("=== Final state  (day 365) ===")
header = f"{'Patch':>5}  {'N':>8}  {'S':>10}  {'E':>6}  {'I':>6}  {'R':>10}  {'Attack%':>8}"
print(header)
print("-" * len(header))

for p in range(n_patches):
    N   = int(patch_populations[p])
    Sf  = nodes.S[-1, p]
    Ef  = nodes.E[-1, p]
    If  = nodes.I[-1, p]
    Rf  = nodes.R[-1, p]
    new_R       = Rf - float(R0arr[p])
    attack_rate = new_R / float(S0[p]) * 100.0
    print(f"{p:>5}  {N:>8,}  {Sf:>10.0f}  {Ef:>6.1f}  {If:>6.1f}  "
          f"{Rf:>10.0f}  {attack_rate:>7.1f}%")

print("\n=== Peak infectious ===")
for p in range(n_patches):
    peak_day = int(nodes.I[:, p].argmax())
    peak_I   = nodes.I[peak_day, p]
    print(f"  Patch {p} (N={patch_populations[p]:,}): "
          f"peak I = {peak_I:.0f}  ({peak_I / patch_populations[p] * 100:.1f}%)  "
          f"on day {peak_day}")


# =========================================================================
# 9.  VISUALISATION
# =========================================================================

days   = np.arange(nticks + 1)
colors = {"S": "steelblue", "E": "darkorange", "I": "firebrick", "R": "forestgreen"}

fig, axes = plt.subplots(2, 2, figsize=(13, 8), sharex=True, sharey=True)
axes = axes.flatten()

for p, ax in enumerate(axes):
    N          = patch_populations[p]
    travel_pct = (1.0 - phi[p, p]) * 100.0

    ax.plot(days, nodes.S[:, p] / N * 100, lw=2, label="S", color=colors["S"])
    ax.plot(days, nodes.E[:, p] / N * 100, lw=2, label="E", color=colors["E"])
    ax.plot(days, nodes.I[:, p] / N * 100, lw=2, label="I", color=colors["I"])
    ax.plot(days, nodes.R[:, p] / N * 100, lw=2, label="R", color=colors["R"])
    ax.set_title(
        f"Patch {p}  (N = {N:,})  [{travel_pct:.1f}% travel]",
        fontsize=10,
    )
    ax.set_ylabel("Population (%)")
    ax.set_xlabel("Day")
    ax.set_xlim(0, nticks)
    ax.set_ylim(0, 100)
    ax.legend(loc="center right", fontsize=9)
    ax.grid(True, alpha=0.3)

fig.suptitle(
    f"4-Patch SEIR  |  R₀ = {R0}  ·  latent = {latent_period} d  "
    f"·  infectious = {infectious_period} d  |  "
    f"Gravity coupling  k={k_grav}, a={int(a_grav)}, b={int(b_grav)}, "
    f"c={c_grav}, cap={int(max_export * 100)}%",
    fontsize=11,
)
plt.tight_layout()
plt.savefig("seir_4patch_gravity.png", dpi=150, bbox_inches="tight")
print("\nPlot saved → seir_4patch_gravity.png")
plt.show()
```

Add seasonal forcing to the transmission. Winter peak (days 0-90) at 1.3x
baseline, summer trough (days 150-240) at 0.7x baseline. Use LASER's ValuesMap
to create the seasonal profile. Update the code and show the complete modified
script. Do not install any packages.

IMPORTANT: Output the complete Python code in a single ```python code block in your response. Do not write it to a file — include it directly in your answer.