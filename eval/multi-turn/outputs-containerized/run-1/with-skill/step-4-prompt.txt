Here is the code from the previous step:

```python
"""
4-patch SEIR model with gravity-model spatial coupling and seasonal forcing
(laser-generic v1.0.0).

Disease parameters:
  R0 = 5, latent period = 4 days, infectious period = 10 days

Initial conditions (per patch):
  90% Susceptible | 1% Infectious | 9% Recovered | 0% Exposed

Spatial coupling: gravity model  F_ij = k · N_i^a · N_j^b / d_ij^c
  k=0.01, a=1, b=1, c=1.5
  Patches in a line, 75 km apart.
  Row-normalized to cap each patch's total FOI export at 15%.

Seasonal forcing (ValuesMap):
  Days   0– 90:  1.3x baseline (winter peak plateau)
  Days  91–149:  cosine ramp down 1.3x → 0.7x
  Days 150–240:  0.7x baseline (summer trough plateau)
  Days 241–364:  cosine ramp up  0.7x → 1.3x

Simulation duration: 1 year (365 days).
"""

import numpy as np
import geopandas as gpd
from shapely.geometry import Point
from laser.core.propertyset import PropertySet
import laser.core.distributions as dists
from laser.generic import SEIR, Model
from laser.generic.utils import ValuesMap
import matplotlib.pyplot as plt

# ── 1. Disease parameters ──────────────────────────────────────────────────────
R0              = 5.0
latent_days     = 4.0    # mean exposed (E) period
infectious_days = 10.0   # mean infectious (I) period

# beta = R0 / D_I  (standard SIR/SEIR relationship)
beta   = R0 / infectious_days   # = 0.5 per day
nticks = 365                    # 1 year

print(f"beta = {beta:.4f}  (R0={R0}, infectious_period={infectious_days}d)")

# ── 2. Patch populations and initial conditions ────────────────────────────────
populations = np.array([100_000, 200_000, 150_000, 80_000], dtype=np.int32)
nnodes      = len(populations)

S_init = np.round(0.90 * populations).astype(np.int32)
I_init = np.round(0.01 * populations).astype(np.int32)
R_init = np.round(0.09 * populations).astype(np.int32)
E_init = populations - S_init - I_init - R_init   # = 0 (90+1+9 = 100%)

# Verify
assert np.all(S_init + E_init + I_init + R_init == populations), \
    "S + E + I + R must equal N in every patch"
assert np.all(I_init > 0), \
    "Every patch must have at least one initial infectious agent"

print(
    f"Initial conditions verified:\n"
    f"  Total N={populations.sum():,}, "
    f"S={S_init.sum():,} (90%), "
    f"I={I_init.sum():,} (1%), "
    f"R={R_init.sum():,} (9%), "
    f"E={E_init.sum():,} (0%)"
)

# ── 3. Gravity-model spatial network ──────────────────────────────────────────
# Patches in a line, 75 km apart.
positions_km = np.array([0.0, 75.0, 150.0, 225.0])

# Pairwise distance matrix (km); diagonal → inf to keep self-terms at zero.
dist_km = np.abs(positions_km[:, None] - positions_km[None, :])
np.fill_diagonal(dist_km, np.inf)

# Gravity parameters
gravity_k = 0.01
gravity_a = 1.0    # N_i exponent
gravity_b = 1.0    # N_j exponent
gravity_c = 1.5    # distance exponent

# Raw flows  F_ij = k · N_i^a · N_j^b / d_ij^c  (off-diagonal; diagonal is 0)
F_raw = (
    gravity_k
    * populations[:, None] ** gravity_a
    * populations[None, :] ** gravity_b
    / dist_km ** gravity_c
)
np.fill_diagonal(F_raw, 0.0)

# Convert to dimensionless export-fraction matrix:
#   f_ij = F_ij / N_i  =  fraction of patch i's FOI it "sends" to patch j.
export_frac_matrix = F_raw / populations[:, None]

# Row-cap: if a patch's total export exceeds 15%, scale that row down uniformly.
max_export_frac = 0.15
export_total    = export_frac_matrix.sum(axis=1)
cap_scale       = np.where(
    export_total > max_export_frac,
    max_export_frac / export_total,
    1.0,
)
network = export_frac_matrix * cap_scale[:, None]

# Sanity checks
assert np.all(network >= 0), "Negative network weight detected"
assert network.sum(axis=1).max() <= max_export_frac + 1e-10, \
    f"Export cap violated: max row sum = {network.sum(axis=1).max():.4f}"
assert network.sum() > 0, "Network is all zeros — no spatial coupling"

row_sums = network.sum(axis=1)
print(f"\nGravity network (k={gravity_k}, a={gravity_a}, b={gravity_b}, c={gravity_c}):")
print("  network[i,j] = fraction of patch i's FOI exported to patch j")
print(np.array2string(network, precision=4, suppress_small=True))
print(f"  Row sums (FOI export fraction per patch): {row_sums.round(4)}")
print(f"  15% cap applied to: "
      f"{(export_total > max_export_frac).sum()}/{nnodes} patches")

# ── 4. Seasonal forcing profile ────────────────────────────────────────────────
# Piecewise seasonal multiplier on beta:
#   Days   0– 90:  1.3x plateau  (winter peak)
#   Days  91–149:  cosine ramp down from 1.3x to 0.7x  (59 transition steps)
#   Days 150–240:  0.7x plateau  (summer trough)
#   Days 241–364:  cosine ramp up from 0.7x to 1.3x  (124 transition steps)
#
# The cos-ramp formula for a smooth S-curve between values hi and lo over n
# steps (inclusive endpoints) is:
#   hi→lo:  0.5*(hi+lo) + 0.5*(hi-lo)*cos(π·i/(n-1)),  i = 0 … n-1
#   lo→hi:  0.5*(hi+lo) - 0.5*(hi-lo)*cos(π·i/(n-1)),  i = 0 … n-1
# Both evaluate to hi at i=0 and lo at i=n-1 (or lo at i=0 and hi at i=n-1).
#
# Mean of the two flat plateaus: (91*1.3 + 91*0.7) / 365 = 182/365 ≈ 0.499.
# Mean of each cosine transition ≈ midpoint (0.5*(1.3+0.7)=1.0) because the
# cosine integrates to ~0 over a half-period.  Full-year mean ≈ 1.0.

season_hi = 1.3
season_lo = 0.7

season_365 = np.ones(365, dtype=np.float64)

# ── Plateau regions ─────────────────────────────────────────────────────
season_365[0:91]   = season_hi   # days   0–90  (winter peak)
season_365[150:241] = season_lo  # days 150–240 (summer trough)

# ── Transition: winter peak → summer trough  (days 91–149, 59 steps) ────
n_down  = 150 - 91                          # = 59
i_down  = np.arange(n_down)                 # 0 … 58
season_365[91:150] = (
    0.5 * (season_hi + season_lo)
    + 0.5 * (season_hi - season_lo) * np.cos(np.pi * i_down / (n_down - 1))
)

# ── Transition: summer trough → winter peak  (days 241–364, 124 steps) ──
n_up   = 365 - 241                          # = 124
i_up   = np.arange(n_up)                    # 0 … 123
season_365[241:365] = (
    0.5 * (season_hi + season_lo)
    - 0.5 * (season_hi - season_lo) * np.cos(np.pi * i_up / (n_up - 1))
)

# ── Validate ─────────────────────────────────────────────────────────────
assert abs(season_365.mean() - 1.0) < 0.02, \
    f"Seasonal profile mean={season_365.mean():.4f}, expected ~1.0"
assert abs(season_365[0]   - season_hi) < 1e-9, "Day 0 must equal 1.3"
assert abs(season_365[90]  - season_hi) < 1e-9, "Day 90 must equal 1.3"
assert abs(season_365[150] - season_lo) < 1e-9, "Day 150 must equal 0.7"
assert abs(season_365[240] - season_lo) < 1e-9, "Day 240 must equal 0.7"
# Continuity at transition boundaries
assert abs(season_365[91]  - season_hi) < 1e-9, "Ramp-down start must be 1.3"
assert abs(season_365[149] - season_lo) < 1e-9, "Ramp-down end must be 0.7"
assert abs(season_365[241] - season_lo) < 1e-9, "Ramp-up start must be 0.7"
assert abs(season_365[364] - season_hi) < 1e-9, "Ramp-up end must be 1.3"

print(f"\nSeasonal profile (365-day):")
print(f"  mean={season_365.mean():.4f}, "
      f"min={season_365.min():.4f} (day {np.argmin(season_365)}), "
      f"max={season_365.max():.4f} (day {np.argmax(season_365)})")
print(f"  Winter peak  (days  0– 90): {season_365[ 0:91].min():.2f}–{season_365[ 0:91].max():.2f}x")
print(f"  Summer trough(days150–240): {season_365[150:241].min():.2f}–{season_365[150:241].max():.2f}x")

# ── Build ValuesMap for nticks days across nnodes patches ─────────────────────
# Tile the 365-day profile to cover the full simulation (nticks may be > 365).
season_tiled = np.tile(season_365, nticks // 365 + 1)[:nticks]
seasonality  = ValuesMap.from_timeseries(season_tiled, nnodes)

print(f"  ValuesMap shape: {seasonality.values.shape}  (nticks={nticks}, nnodes={nnodes})")

# ── 5. Scenario GeoDataFrame ───────────────────────────────────────────────────
# Geometry reflects the 1-D spatial arrangement (lon fixed, lat offset by km).
# 1 degree latitude ≈ 111 km.
lons = np.full(nnodes, 70.0)
lats = 30.0 + positions_km / 111.0

scenario = gpd.GeoDataFrame(
    {
        "nodeid":     np.arange(nnodes, dtype=np.int32),
        "name":       [f"Patch_{i}" for i in range(nnodes)],
        "population": populations,
        "S":          S_init,
        "E":          E_init,
        "I":          I_init,
        "R":          R_init,
        "geometry":   [Point(lon, lat) for lon, lat in zip(lons, lats)],
    },
    crs="EPSG:4326",
)

# ── 6. Model parameters ────────────────────────────────────────────────────────
params = PropertySet(
    {
        "prng_seed": 42,
        "nticks":    nticks,
        "beta":      beta,
    }
)

# ── 7. Duration distributions ──────────────────────────────────────────────────
# gamma(shape, scale) → mean = shape * scale, variance = shape * scale²
#
# Exposed:    shape=16, scale=0.25 → mean = 4.0 days, std ≈ 1.0 day
# Infectious: shape=40, scale=0.25 → mean = 10.0 days, std ≈ 1.6 days
expdurdist = dists.gamma(shape=16, scale=0.25)   # latent period
infdurdist = dists.gamma(shape=40, scale=0.25)   # infectious period

# ── 8. Build model and install gravity network ─────────────────────────────────
# birthrates=None → static population (no births/deaths).
model = Model(scenario, params, birthrates=None)

# Install gravity-model network.
model.network = network
assert model.network.sum() > 0, "Network must be non-zero for spatial coupling"

# ── 9. Assemble components ─────────────────────────────────────────────────────
# Ordering: Susceptible first and Recovered last ensure S+E+I+R = N invariant.
# Transmission runs after Recovered so it reads the fully-updated compartments.
# seasonality=ValuesMap scales the instantaneous beta at each tick.
model.components = [
    SEIR.Susceptible(model),
    SEIR.Exposed(model, expdurdist, infdurdist),
    SEIR.Infectious(model, infdurdist),
    SEIR.Recovered(model),
    SEIR.Transmission(model, expdurdist, seasonality=seasonality),
]

# ── 10. Run ────────────────────────────────────────────────────────────────────
print("\nRunning simulation ...")
model.run("4-Patch SEIR with Gravity Coupling + Seasonal Forcing")
print("Done.\n")

# ── 11. Post-run verification ──────────────────────────────────────────────────
S = model.nodes.S[:nticks, :]    # shape (nticks, nnodes)
E = model.nodes.E[:nticks, :]
I = model.nodes.I[:nticks, :]
R = model.nodes.R[:nticks, :]
N = S + E + I + R

# 11a. Population conservation (no demographics → N constant per patch)
for i in range(nnodes):
    N_i = N[:, i]
    assert N_i.min() == N_i.max(), (
        f"Population not conserved in Patch {i}: "
        f"min={N_i.min():,}, max={N_i.max():,}"
    )

# 11b. Non-negativity
assert np.all(S >= 0) and np.all(E >= 0) and np.all(I >= 0) and np.all(R >= 0), \
    "Negative compartment count detected"

# 11c. Epidemic occurred in every patch
cumulative_infections = model.nodes.newly_infected[:nticks, :].sum(axis=0)
assert np.all(cumulative_infections > 0), (
    f"No infections in patch(es): {np.where(cumulative_infections == 0)[0]}"
)

print("Verification passed.")
print(f"{'Patch':<10} {'Population':>12} {'Total Infected':>16} {'Attack Rate':>12}")
print("-" * 52)
for i in range(nnodes):
    ar = cumulative_infections[i] / populations[i]
    print(
        f"Patch {i:<4}  {populations[i]:>12,}  "
        f"{cumulative_infections[i]:>14,.0f}  {ar:>11.1%}"
    )
total_pop = populations.sum()
total_inf = cumulative_infections.sum()
print("-" * 52)
print(f"{'Total':<10} {total_pop:>12,}  {total_inf:>14,.0f}  {total_inf/total_pop:>11.1%}")

# ── 12. Diagnostic plots ───────────────────────────────────────────────────────
days         = np.arange(nticks)
patch_labels = [f"Patch {i}  (N={populations[i]//1000}k)" for i in range(nnodes)]
colors       = ["tab:blue", "tab:orange", "tab:green", "tab:red"]

fig, axes = plt.subplots(2, 3, figsize=(18, 8))
fig.suptitle(
    f"4-Patch SEIR with Gravity Coupling + Seasonal Forcing  |  "
    f"R₀={R0}, β={beta}  |  "
    f"k={gravity_k}, a={gravity_a}, b={gravity_b}, c={gravity_c}  |  "
    f"max export={max_export_frac:.0%}  |  "
    f"seasonal: {season_lo}×–{season_hi}× (winter peak days 0–90)",
    fontsize=10,
)

# Panel A: seasonal forcing profile
ax = axes[0, 0]
ax.fill_between(days, season_365, 1.0,
                where=season_365 >= 1.0, alpha=0.25, color="steelblue",
                label="Above baseline (winter)")
ax.fill_between(days, season_365, 1.0,
                where=season_365 <= 1.0, alpha=0.25, color="tomato",
                label="Below baseline (summer)")
ax.plot(days, season_365, color="black", linewidth=1.5)
ax.axhline(1.0, color="gray", linewidth=0.8, linestyle="--")
ax.axvspan(0,   90,  alpha=0.08, color="steelblue")   # winter plateau
ax.axvspan(150, 240, alpha=0.08, color="tomato")       # summer plateau
ax.set_title("Seasonal Forcing Multiplier")
ax.set_xlabel("Day of Year")
ax.set_ylabel("β multiplier")
ax.set_ylim(0.5, 1.5)
ax.legend(fontsize=8)
ax.grid(alpha=0.3)

# Panel B: daily new infections by patch
ax = axes[0, 1]
for i in range(nnodes):
    ax.plot(days, model.nodes.newly_infected[:nticks, i],
            label=patch_labels[i], color=colors[i])
ax.set_title("Daily New Infections by Patch")
ax.set_xlabel("Day")
ax.set_ylabel("New Infections")
ax.legend(fontsize=8)
ax.grid(alpha=0.3)

# Panel C: susceptible fraction S/N by patch
ax = axes[0, 2]
for i in range(nnodes):
    ax.plot(days, S[:, i] / populations[i],
            label=patch_labels[i], color=colors[i])
ax.set_title("Susceptible Fraction  S/N  by Patch")
ax.set_xlabel("Day")
ax.set_ylabel("S / N")
ax.legend(fontsize=8)
ax.grid(alpha=0.3)

# Panel D: aggregate SEIR compartments (all patches combined)
ax = axes[1, 0]
ax.plot(days, S.sum(axis=1) / total_pop, label="S", color="tab:blue")
ax.plot(days, E.sum(axis=1) / total_pop, label="E", color="tab:orange")
ax.plot(days, I.sum(axis=1) / total_pop, label="I", color="tab:red")
ax.plot(days, R.sum(axis=1) / total_pop, label="R", color="tab:green")
ax.set_title("Aggregate SEIR Dynamics  (All Patches)")
ax.set_xlabel("Day")
ax.set_ylabel("Fraction of Population")
ax.legend()
ax.grid(alpha=0.3)

# Panel E: total daily incidence across all patches
ax = axes[1, 1]
ax.plot(days, model.nodes.newly_infected[:nticks, :].sum(axis=1), color="black")
ax.set_title("Total Daily New Infections  (All Patches)")
ax.set_xlabel("Day")
ax.set_ylabel("New Infections")
ax.grid(alpha=0.3)

# Panel F: effective beta over time (beta * seasonal multiplier)
ax = axes[1, 2]
ax.plot(days, beta * season_365, color="darkviolet", linewidth=1.5)
ax.axhline(beta, color="gray", linewidth=0.8, linestyle="--", label=f"β baseline = {beta}")
ax.set_title("Effective β = β × Seasonal Multiplier")
ax.set_xlabel("Day")
ax.set_ylabel("Effective β (per day)")
ax.legend(fontsize=9)
ax.grid(alpha=0.3)

plt.tight_layout()
plt.savefig("seir_4patch_gravity.png", dpi=100, bbox_inches="tight")
plt.show()
print("\nPlot saved: seir_4patch_gravity.png")
```

The model runs but all patches show identical infection curves, suggesting spatial coupling isn't working. Debug and fix the issue. Show the complete corrected script. Do not install any packages.

IMPORTANT: Output the complete Python code in a single ```python code block in your response. Do not write it to a file — include it directly in your answer.